package org.motechproject.mds.osgi;

import org.eclipse.gemini.blueprint.util.OsgiStringUtils;
import org.motechproject.mds.annotations.internal.MDSAnnotationProcessor;
import org.motechproject.mds.service.JarGeneratorService;
import org.motechproject.mds.util.MdsBundleHelper;
import org.osgi.framework.Bundle;
import org.osgi.framework.BundleContext;
import org.osgi.framework.BundleEvent;
import org.osgi.framework.SynchronousBundleListener;
import org.osgi.framework.wiring.FrameworkWiring;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import static org.apache.commons.lang.StringUtils.startsWith;

/**
 * The <code>MdsBundleWatcher</code> in Motech Data Services listens for bundle installation and
 * processes the annotations in the given bundle. It also processes all installed bundles after startup.
 * After annotations are found in a bundle, the entities jar is regenerated and the target bundle is refreshed.
 */
@Component
public class MdsBundleWatcher implements SynchronousBundleListener {
    private static final Logger LOGGER = LoggerFactory.getLogger(MdsBundleWatcher.class);

    private MDSAnnotationProcessor processor;
    private JarGeneratorService jarGeneratorService;
    private BundleContext bundleContext;
    private EntitiesBundleMonitor monitor;

    private static final int MAX_WAIT_TO_RESOLVE = 10;

    private final Object lock = new Object();

    // called by the initializer after the initial entities bundle was generated
    public void start() {
        LOGGER.info("Scanning for MDS annotations");
        processInstalledBundles();
        bundleContext.addBundleListener(this);
    }

    private void processInstalledBundles() {
        List<Bundle> bundles = new ArrayList<>();
        boolean needRefresh = false;

        for (Bundle bundle : bundleContext.getBundles()) {
            boolean annotationsFound = process(bundle);

            if (annotationsFound) {
                bundles.add(bundle);
                needRefresh = true;
            }
        }

        // if we found annotations, we will refresh the bundle in order to start weaving the
        // classes it exposes
        if (needRefresh) {
            refreshBundles(bundles);
        }
    }

    /**
     * Invoked, when an event about bundle change is received. In case a new bundle gets installed
     * or an existing bundle is updated, we need to scan that bundle for MDS annotations and process them.
     *
     * @param event BundleEvent, generated by the OSGi framework
     */
    @Override
    public void bundleChanged(BundleEvent event) {
        Bundle bundle = event.getBundle();

        int eventType = event.getType();

        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("Bundle event of type {} received from {}: {} -> {}", OsgiStringUtils.nullSafeBundleEventToString(event.getType()),
                    bundle.getSymbolicName(), String.valueOf(eventType), String.valueOf(bundle.getState()));
        }

        handleBundleEvent(bundle, eventType);
    }

    private void handleBundleEvent(Bundle bundle, int eventType) {
        if (eventType == BundleEvent.INSTALLED || eventType == BundleEvent.UPDATED) {
            boolean needRefresh = process(bundle);

            // if we found annotations, we will refresh the bundle in order to start weaving the
            // classes it exposes
            if (needRefresh) {
                refreshBundle(bundle);
            }
        } else if (eventType == BundleEvent.UNRESOLVED && !skipBundle(bundle)) {
            MdsBundleHelper.unregisterBundleJDOClasses(bundle);
        } else if (eventType == BundleEvent.UNINSTALLED && !skipBundle(bundle)) {
            refreshBundle(bundle);
        }
    }

    private boolean process(Bundle bundle) {
        if (skipBundle(bundle)) {
            return false;
        }

        synchronized (lock) {
            // Before we process annotations, we wait until bundle resolves its dependencies
            int count = 0;
            while (bundle.getState() < Bundle.RESOLVED && count < MAX_WAIT_TO_RESOLVE) {
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    LOGGER.error("Interrupted");
                }
                count++;
            }

            LOGGER.debug("Processing bundle {}", bundle.getSymbolicName());
            return processor.processAnnotations(bundle);
        }
    }

    private boolean skipBundle(Bundle bundle) {
        // we skip the generated entities bundle, MDS bundle and the framework bundle
        if (MdsBundleHelper.isMdsBundle(bundle) || MdsBundleHelper.isMdsEntitiesBundle(bundle) ||
                MdsBundleHelper.isFrameworkBundle(bundle)) {
            return true;
        }

        // we also skip bundles which locations start with "link:", as these are pax exam bundles, which we
        // encounter only during tests. Maybe in some distant future, support for resolving these locations will be
        // added, but there is no need to do it right now.
        if (startsWith(bundle.getLocation(), "link:") || startsWith(bundle.getLocation(), "local")) {
            return true;
        }

        // finally we skip bundles that don't have an MDS dependency
        if (!MdsBundleHelper.isBundleMdsDependent(bundle)) {
            return true;
        }

        return false;
    }

    private void refreshBundle(Bundle bundle) {
        refreshBundles(Arrays.asList(bundle));
    }

    private void refreshBundles(List<Bundle> bundles) {
        if (LOGGER.isInfoEnabled()) {
            for (Bundle bundle : bundles) {
                LOGGER.info("Refreshing wiring for bundle {}", bundle.getSymbolicName());
            }
        }

        // we generate the entities bundle but not start it to avoid exceptions when the framework
        // will refresh bundles
        jarGeneratorService.regenerateMdsDataBundle(true, false);

        FrameworkWiring framework = bundleContext.getBundle(0).adapt(FrameworkWiring.class);
        framework.refreshBundles(bundles);

        // give the framework 3 seconds to do a refresh
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            LOGGER.error("Interrupted");
        }

        // after refreshing all bundles we can start the entities bundle
        monitor.start();
    }

    @Autowired
    public void setProcessor(MDSAnnotationProcessor processor) {
        this.processor = processor;
    }

    @Autowired
    public void setJarGeneratorService(JarGeneratorService jarGeneratorService) {
        this.jarGeneratorService = jarGeneratorService;
    }

    @Autowired
    public void setBundleContext(BundleContext bundleContext) {
        this.bundleContext = bundleContext;
    }

    @Autowired
    public void setMonitor(EntitiesBundleMonitor monitor) {
        this.monitor = monitor;
    }
}
